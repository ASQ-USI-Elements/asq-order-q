<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../asq-base/asq-base.html">
<link rel="import" href="../asq-match/asq-match.html">
<link rel="import" href="../paper-button/paper-button.html">

<!--
TODO ......

##### Example
    <asq-order >
      <div targets>
        <div target name="Long"><span>Long</span></div>
        <div target name="Short"><span>Short</span></div>
      </div>
      <div objects>
        <div object name="glas">Gl<b>a</b>s</div>
        <div object name="nudeln">N<b>u</b>deln</div>
        <div object name="platz">Pl<b>a</b>tz</div>
        <div object name="vier">v<b>i</b>er</div>
      </div>
    </asq-order>


@element asq-order
@group ASQ Elements
@blurb ...
@homepage http://github.com/ASQ_USI/asq-order
-->
<polymer-element name="asq-order" attributes="mode targets objects solution hint">
  <template>
    <style>
    
    </style>
    
    <asq-match id="match" mode="{{mode}}" on-asq-match="{{onMatch}}"></asq-match>
    <content id="stem" select="asq-stem" ></content>
    <wrapper><content id="items" select="*" ></content></wrapper>
    
  </template>

  <script>
  (function() {


    var p = {

      valueattr: 'name',

      targets: null,

      objects: null,

      itemsSelector: '',

      activateEvent: 'tap',

      mode: '1-m',

      interchangeable: true,

      solution: '{und} {kalt} {es ist} {schneit}',

      hint: false,


      ready: function() {
        this.activateListener = this.onObjectTap.bind(this);
        this.objectsObserver = new MutationObserver(this.updateObjects.bind(this));

        if (!this.targets) this.targets = this;
        if (!this.objects) this.objects = this;
      },

      updateObjects: function() {
        for (var x of this.getUnmatchedObjects()) {
          this.removeListener(x);
          this.addListener(x);
        }
      },


      targetsChanged: function(old) {
        if (old && typeof old === "object") {
          this.removeListener(old);
          this.targetObserver.disconnect();
        }
        if (!this.targets) this.targets = this;
        if ( typeof this.targets === "string" ) {
          var targets = this.parentNode.querySelector(this.targets);
          if ( targets ) this.targets = targets;
          else this.targets = this;
        } 
      },

      objectsChanged: function(old) {
        if (old && typeof old === "object") {
          this.removeListener(old);
          this.objectsObserver.disconnect();
        }
        if (!this.objects) this.objects = this;
        if ( typeof this.objects === "string") {
          var objects = this.parentNode.querySelector(this.objects);

          if ( objects ) this.objects = objects;
          else this.objects = this;
        } 
        this.objectsObserver.observe(this.objects, {childList: true});


       for (var x of this.getUnmatchedObjects()) {
          this.addListener(x);
        }
      },

      addListener: function(node) {
        Polymer.addEventListener(node, this.activateEvent, this.activateListener);
      },

      removeListener: function(node) {
        Polymer.removeEventListener(node, this.activateEvent, this.activateListener);
      },

      onSwitchTarget: function(event) {
        this.switchTarget(event.target.parentNode);
        event.stopPropagation();
      },

      switchTarget: function(object) {
        var targets = this.getTargets();
        var oldTarget = object.parentNode;
        if (!oldTarget || !targets || targets.length <= 1) return;

        var index = targets.indexOf(oldTarget);
        index = index+1 == targets.length ? 0 : index+1;
        var peerBucket = targets[index];

        this.match(peerBucket, object);
      },

      onObjectTap: function(e) {
        var object = e.currentTarget;
        if ( !object ) return;          

        this.match(this.getTarget(), object);
      },


      onMatch: function(e) {
        var target = this.getTarget().getAttribute(this.valueattr) == e.detail.key ?
                    this.getTarget() : undefined;
        var object = this.findObjecttByAttribute(e.detail.value);

        if ( !target || !object ) {
          return
        }

        if ( e.detail.isMatch ) {
          target.appendChild(object);
        } else {
          this.objects.appendChild(object);
        }

        this.prettyPrint();
      },

      isMatch: function(k, v) {
        return this.$.match.isMatch(k.getAttribute(this.valueattr), 
          v.getAttribute(this.valueattr));
      },

      /**
       * Set up a match between target and object
       * @method match
       * @param  {Object} k target
       * @param  {Object} v object
       */
      match: function(target, object) {

        k =  typeof target === 'object' ? 
            target.getAttribute(this.valueattr) : target;
        v = typeof object === 'object' ? 
            object.getAttribute(this.valueattr) : object;
        
        this.$.match.match(k, v);
      },

      findObjecttByAttribute: function(attr) {

        for ( var object of this.getUnmatchedObjects() ) {
          if ( object.getAttribute(this.valueattr) == attr) {
            return object;
          }
        }

        var target = this.getTarget();
        for ( var object of this.getMatchedObjectsOfTarget(target) ) {
          if ( object.getAttribute(this.valueattr) == attr) {
            return object;
          }
        }
        return null;
      },

      getMatchedObjectsOfTarget: function(target) {
        var objects = [];
        target.childNodes.array().forEach(function(e) {
          e.hasAttribute('object') && objects.push(e);
        });
        return objects;
      },

      getTarget: function() {
        var targets = [];
        this.targets.childNodes.array().forEach(function(e) {
          e.nodeType == 1 && e.hasAttribute('target') && targets.push(e);
        });
        return targets.length >= 1 ? targets[0] : null;
      },

      /**
       * Get all unmatched objects.
       * @method getUnmatchedObjects 
       * @return {array} UnmatchedObjects
       */
      getUnmatchedObjects: function() {
        var objects = [];
        this.objects.childNodes.array().forEach(function(e) {
            e.nodeType == 1 && e.hasAttribute('object') && objects.push(e);
        });
        return objects.reverse();

      },

      prettyPrint: function() {
        var matches = this.$.match.getMatches();
        console.log('- - - - match', matches.length, ' - - - -');
        matches.forEach(function(m, index){
          console.log('  ', index, ' : ' , m.key, m.value);
        });
        console.log('\n');
      },

      /**
       * The `submit` method returns an object that respresents the submission of this question. The object has the following structure:

           {
              questionUid: this.uid, 
              timestamp: new Date(),

              // Array of the result of submit() called for each option of the question
              submission: [] 
           }
       * Only enabled when the `role` of the element is <b>viewer</b>.
       *
       * @method submit
       */
      submit: function() {
        if ( this.role !== this.roles.VIEWER ) {
          return;
        }

        var submission = this.$.match.getMatches();

        return {
          questionUid: this.uid,
          timestamp: new Date(),
          submission: submission
        };
      }

    }

    ASQ.asqify(p, true);
    Polymer('asq-order', p);

  })();
  </script>
</polymer-element>
